use crate::what::*;

grammar;

match {
    "&&",
    "||",
    "==",
    "!=",
    "!",
    "+",
    "-",
    "*",
    "/",
    "putchar",
    "putnum",
    "getchar",
    "getnum",
    "alloc",
    "free",
    "while",
    "if",
    "let",
    "do",
    "end",
    "int",
    "bool",
    "char",
    "void",
    "in",
    "fn",
    ":",
    "->",
    "=",
    "$",
    "&",
    "true",
    "false"
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*"
} else {
    _
}



AndOrOr: String = {
    "&&" => <>.to_string(),
    "||" => <>.to_string()
}

EqOrNeq: String = {
    "==" => <>.to_string(),
    "!=" => <>.to_string()
}

AddOrSub: String = {
    "+" => <>.to_string(),
    "-" => <>.to_string()
}

MulOrDiv: String = {
    "*" => <>.to_string(),
    "/" => <>.to_string()
}

pub What: Expr = Expr => <>;

Expr: Expr = {
    "while" <cond: AndOrOrExpr> "do" <body: (Expr ";")+> "end"=> Expr::While(Box::new(cond), Box::new(Expr::Block(body.into_iter().map(|e| e.0).collect()))),
    "if" <cond: AndOrOrExpr> "do" <body: (Expr ";")+> "end" => Expr::If(Box::new(cond), Box::new(Expr::Block(body.into_iter().map(|e| e.0).collect()))),
    "let" <var: Identifier> ":" <t:Type> "=" <value: Expr> "in" <body: Expr> "end" => Expr::Let(var, t, Box::new(value), Box::new(body)),
    "*" <addr:AtomicExpr> "=" <value: Expr> => Expr::DerefAssign(Box::new(addr), Box::new(value)),
    <var: Identifier> "=" <value: Expr> => Expr::Assign(var, Box::new(value)),
    "fn" <var: Identifier> "(" <args:List<(Identifier ":" AtomicType)>> ")" "->" <ret_type:Type> "=" <body:Expr> "in" <result:Expr> => {
        let mut arg_names = vec![];
        let mut arg_types = vec![];

        for (name, _, t) in args.clone() {
            arg_names.push(name);
            arg_types.push(t);
        }

        Expr::Let(
            var,
            Type::Function(arg_types, Box::new(ret_type.clone())),
            Box::new(Expr::Function(args.into_iter().map(|(n, _, t)| (n, t)).collect(), ret_type, Box::new(body))),
            Box::new(result)
        )
    },
    AndOrOrExpr => <>,
}

AndOrOrExpr: Expr = {
    <mut head:EqNeqExpr> <mut tail:(AndOrOr EqNeqExpr)*> => {
        tail.reverse();
        while let Some((op, expr)) = tail.pop() {
            head = if op == "&&" {
                Expr::And(Box::new(head), Box::new(expr))
            } else {
                Expr::Or(Box::new(head), Box::new(expr))
            }
        }
        head
    }
}

EqNeqExpr: Expr = {
    <mut head:NotExpr> <mut tail:(EqOrNeq NotExpr)*> => {
        tail.reverse();
        while let Some((op, expr)) = tail.pop() {
            head = if op == "==" {
                Expr::Eq(Box::new(head), Box::new(expr))
            } else {
                Expr::Neq(Box::new(head), Box::new(expr))
            }
        }
        head
    }
}

NotExpr: Expr = {
    "!" <expr:NotExpr> => Expr::Not(Box::new(expr)),
    AddSubExpr => <>,
}


AddSubExpr: Expr = {
    <mut head:MulDivExpr> <mut tail:(AddOrSub MulDivExpr)*> => {
        tail.reverse();
        while let Some((op, expr)) = tail.pop() {
            head = if op == "+" {
                Expr::Add(Box::new(head), Box::new(expr))
            } else {
                Expr::Sub(Box::new(head), Box::new(expr))
            }
        }
        head
    }
}

MulDivExpr: Expr = {
    <mut head:ComplexExpr> <mut tail:(MulOrDiv ComplexExpr)*> => {
        tail.reverse();
        while let Some((op, expr)) = tail.pop() {
            head = if op == "*" {
                Expr::Mul(Box::new(head), Box::new(expr))
            } else {
                Expr::Div(Box::new(head), Box::new(expr))
            }
        }
        head
    }
}

ComplexExpr: Expr = {
    "*" <ComplexExpr> => Expr::Deref(Box::new(<>)),
    SimpleExpr => <>,
}

SimpleExpr: Expr = {
    "putchar" "(" <Expr> ")" => Expr::Putchar(Box::new(<>)),
    "putnum" "(" <Expr> ")" => Expr::Putnum(Box::new(<>)),
    "alloc" "(" <n:Expr> "," <t:Type> ")" => Expr::Alloc(Box::new(n), t),
    "free" "(" <Expr> ")" => Expr::Free(Box::new(<>)),
    "getchar" "(" ")" => Expr::Getchar,
    "getnum" "(" ")" => Expr::Getnum,
    <name:Identifier> "(" <args:List<Expr>> ")" => Expr::Call(name, args),
    AtomicExpr => <>,
}

AtomicExpr: Expr = {
    <Num> => Expr::Integer(<>),
    <Bool> => Expr::Bool(<>),
    <Char> => Expr::Character(<>),
    <Identifier> => Expr::Variable(<>),
    "&" <Identifier> => Expr::Refer(<>),
    "(" <Expr> ")" => <>,
    "do" <block:(Expr ";")+> "end" => Expr::Block(<>.into_iter().map(|e| e.0).collect()),
}

Type: Type = {
    "fn" "(" <args:List<Type>> ")" "->" <ret:AtomicType> => Type::Function(args, Box::new(ret)),
    AtomicType => <>,
}
AtomicType: Type = {
    "&" <AtomicType> => Type::Pointer(Box::new(<>)),
    "int" => Type::Integer,
    "bool" => Type::Bool,
    "char" => Type::Character,
    "void" => Type::Void,
}


List<T>: Vec<T> = {
    <items: (T ",")*> <last: T> => {
        let mut items = items.into_iter().map(|(item, _)| item).collect::<Vec<_>>();
        items.push(last);
        items
    }
}


Str: String = <s:r#""(\\.|[^"])*""#> => String::from(&s[1..s.len()-1]).replace("\\\"", "\"").replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\0", "\0");
Char: char = <s:r#"'(\\.|[^'])'"#> => s.replace("\\'", "'").replace("\\n", "\n").replace("\\r", "\r").replace("\\t", "\t").replace("\\0", "\0").chars().nth(1).unwrap() as char;
Bool: bool = {
    "true" => true,
    "false" => false,
}

Num: u32 = {
    r"[1-9][0-9]*|[0]" => {
        <>.parse::<u32>().unwrap()
    },
}

Identifier: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();